<div align='left'>
    <img src='../assets/formal.svg'>
    <img src='../assets/normal.svg'>
</div>

# Глава 3.3: Типы языка спецификации

Когда основные грамматические правила языка спецификации нам стали известны, стоит обратить внимание
на то, что и как они описывают. На данном этапе правильнее будет задать вопрос: что помогает
грамматике языка спецификации более точно и детально описывать внутреннюю машинерию языка
ECMAScript? При чём тут типы языка спецификации, как они связаны с грамматикой и как реализованы на
страницах стандарта? Это мы и разберём в нашей главе.

## Теория типов данных

Для начала хочется определить, с чем мы имеем дело, когда говорим о чём-то, что имеет какой-то тип.
Попробуем понять, а какую роль вообще в программировании имеют типы и для чего они нужны, как
реализованы.

> In computer science and computer programming, a data **_type_** (or simply type) is a
> **_collection_** or grouping of **_data values_**, usually specified by a set of **_possible
> values_**, a set of allowed **_operations_** on these values, and/or a **_representation_** of
> these values as machine types. A data type specification in a program constrains the possible
> values that an **_expression_**, such as a variable or a function call, **_might take_**.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Data_type)

Очевидно, что типы в языках программирования помогают разработчкам описать значения (данные), с
которыми они вынуждены работать на своём поприще. Особенно важно, что типы существуют не только для
удобства разработчика при создании им некоторого продукта, но и для гарантирования в самом языке
выполнения правил, регулирующих поведение типов данных. В контексте условного общего
программирования не стоит воспринимать типы только лишь относительно так называемых _втроенных
примитивов_
([**_built-in primitive data type_**](https://en.wikipedia.org/wiki/Primitive_data_type)). В разных
языках существуют конструкции, определение которых требует сопоставления нескольких встроенных
типов - _композитный тип данных_
([**_сomposite data type_**](https://en.wikipedia.org/wiki/Composite_data_type)).

Ну и стоит помнить, что есть типы, лишь _косвенно_ связанные с языком, например, **_типы языка
спецификации_.** Зачастую, с точки зрения грамматики самого языка, они являются вспомогательными, но
для правильной работы языка в какой-то системе, например, в _хост-среде_
([host environment](https://tc39.es/ecma262/multipage/overview.html#host-environment)), без таких
типов не обойтись. В основном они описывают какие-то большие и сложные конструкции языка.

## Про типы в ECMAScript

В спецификации существует разделение типов на две системы[^1]:
[система типов языка ECMAScript](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types)
и
[типов языка спецификации](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-specification-types).
Получилось это так, потому что грамматика языка спецификации в совокупности с цепочками алгоритмов
порождает необходимость подробного указания, с какими данными или сущностями работает тот или иной
алгоритм в рамках своей отдельной грамматики. Иначе благодаря избыточной сложности большинства
[алгоритмов](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions)
они не получили бы точного описания, что повлекло бы за собой ещё большее усложнение.

Итак, на уровне внутренних алгоритмов языка ECMAScript мы вынуждены работать как с одной системой
типов, так и с другой. Проблема в том, что они **_пересекаются_** на уровне стандарта, поэтому в них
можно легко запутаться. Вполне вероятно, что одна
[абстрактная операция](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-abstract-operations)
может вернуть в качестве результата нечто, соответствующее типу языка ECMAScript, другая - вернёт
сущность, принадлежащую типу языка спецификации, хотя внутри самой операции алгоритмы будут
оперировать обеими системами типов.

Глава нацелена на развитие умения дифференциировать обе системы типов на уровне алгоритмов языка без
тесного контакта с самими [алгоритмами](/get-started/Chapter_3.md) (_следующая глава_). Мы подробно
разберём **_только систему типов языка спецификации_**, а другую - уже в соответствующей главе про
сам язык ECMAScript.

## Типы спецификации

Начнём разговор более предметно. Типы языка спецификации ECMAScript, согласно стандарту,
представляют из себя
[метаинформацию](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-specification-types)
внутри каждого отдельного алгоритма, которая призвана описывать семантику конструкций языка
ECMAScript и даже его типы.

### Значение

У типов спецификации есть свои значения, по которым их можно отличать. Важно отметить, что, согласно
спецификации, значения таких типов являются **_артефактами спецификации_** и не обязаны
соответствовать чему-либо внутри самого языка ECMAScript. Вдобавок ко всему сказанному значения
типов могут описывать только промежуточные результаты _операции оценки_
([Evaluation](https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-evaluation)), и
не могут хранить свои значения в сущностях языка ECMAScript, например, в _свойствах_
([property](https://tc39.es/ecma262/multipage/overview.html#sec-property)) _объектов_. То есть, по
сути, типы спецификации - это вообще отдельные от языка ECMAScript сущности,
инкапсулированно-имплементированные в отдельную систему типов, помогающую при описании языка и
принимающую участие в работе _host environment_.

### Виды

Давайте детально рассмотрим доступные на сегодняшний день типы спецификации. На страницах стандарта
нам явно представлено 15 разных типов:

#### 1. [Enum Type](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-enum-specification-type)

Это внутренний тип спецификации, введённый для описания значений некоторых других типов.
Обозначается как <font face='sans-serif' size='4'>NORMAL</font>,
<font face='sans-serif' size='4'>RETURN</font> или любое другое слово, отличаясь от всех остальных
<font face='sans-serif' size='4'>SANS-SERIF</font> шрифтом в _верхнем регистре_ при написании. Так
установлено, что **_значение типа_** само по себе и даже в каком-либо контексте **_ничего не
характеризует_**, как бы это ни было странным. Значение типу необходимо таким, каким оно является,
только для дефференциирования среди других значений. В спецификации он выглядит так:

<div align='center'>
    <img src='assets/type1.png' alt='Image with type'>
</div>
<br>

<details>
<summary><i>Интересный факт</i></summary>
<br>

> В [стандарте ES2023](https://tc39.es/ecma262/2023/multipage/) значения типа были представлены в
> _нижнем регистре_ того же шрифта, что путало разработчиков из-за схожести со значениями типов
> самого языка ECMAScript. Благодаря тому что спецификация в какой-то степени совершенствуется,
> сейчас такой проблемы нет.

</details>

#### 2. [List type](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-list-and-record-specification-type)

> [!TIP]  
> Глава находится в разработке

[^1]:
    Авторский термин. В спецификации нет такого понятия, как "_система типов_". Под этим выражением
    я подразумеваю совокупность самих типов и их реализации в рамках спецификации.
